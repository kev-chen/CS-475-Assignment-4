[//]: # (Kevin Chen)
[//]: # (Assignment 4)
[//]: # (CS 475)

# CS-475-Assignment-4
Simple Network Security Protocol


## Configuration
By default, the client is set up to connect to an AWS EC2 instance running the server code. To change this, edit the `serverName` key in `Client/settings.json` to a specific hostname running the server code.

Also by default, both the client and server are set up on port 13456. This can also be changed in `serverPort` key in the `Client/settings.json` and `Server/settings.json` files.

The encryption/decryption is reliant on:
- `Client/client_private_key.pem`
- `Client/server_public_key.pem`
- `Server/client_public_key.pem`
- `Server/server_private_key.pem`

There is only one client set up in the server's clients list, which the client will take the name of by default.

Note: Port 13456 must be used when connecting to the EC2 instance.


## Usage
Make sure the pycrypto module is installed by running 
  ```
    pip3 install pycrypto
  ```

### Client

`cd Client` to get into the Client directory, then run:
  ```
    python3 driver.py
  ```
If all defaults are unchanged, then this will immediately start the authentication algorithm and attempt to connect to the EC2 instance. Upon success, you should see the following:

  ```
    Successfully authorized. Server response: test_client_name,<session_key>
    ec2-52-32-60-227.us-west-2.compute.amazonaws.com>
  ```

Otherwise, failing authentication will be met with:
  ```
    Authentication Failed
  ```
You can cause authentication to fail by:
- Deleting a row from any *.pem file
- Deleting any *.pem file
- Changing the `clientName` key in `Client/settings.json`

Upon a successful connection, there are three commands: `ls`, `pwd`, and `quit` that will be executed on the server machine.

### Server
`cd Server` to get into the Server directory, then run:
  ```
    python3 driver.py
  ```

The server should output `Started listening on port 13456...` when successfully started. 
If running the server code from another machine, be sure to configure the client to connect to that machine in `Client/settings.json`. This setting can be configured to the output of running `hostname` if the server and client are running on the same machine.


# Design
## Overview
The authentication protocol, as given in the assignment:

1. Client sends  E_s(N_c) where  E_s is the server's encryption function based on its public key and  N_c is the name on the client which is authenticating to the server.
2. Server responds with  E_c(D_s(N_c,K_s)) where  E_c is the client's encryption function based on its public key,  D_s is the server's decryption function based on its private key, and K_s is the shared session key, randomly generated by the server.

The essence of this security protocol involves communication between client and server, so there are two portions to the source code. The client implements the behavior given in 1. and the server implements the behavior given in 2.

In this implementation, there is one client and one server. The client has access to its own private key and the server's public key, while the server has access to its own private key and the client's public key.

The client starts by using the server's public key to encrypt the client name and sends that to the server. The server receives the message and decrypts with its private key. If there is any issue with decrypting, then authentication fails. Upon succesfully decrypting the client's message, the server takes the decrypted client name and looks up the public key associated with the client. If there is no such client, then authentication fails. If there is such a client, then the server responds with the client name and a session key, encrypted with the client's public key, and will start listening for commands from this client. The client, upon receiving the server's response, will decrypt with its private key and check if the client name is included in the response. If it is, that means the server was able to successfully decrypt the initial response, proving its identity.

## The Server
There is an instance of the server code running in the cloud on an AWS EC2 instance. The client is set up to be configurable to change which host to try connecting to by modifying the value for the `serverName` key in `Client/settings.json`. 

To run both the client and server on your local machine:
1. Run `hostname` from the command line
2. Use that host name as the value for `serverName` in `Client/settings.json`

## Client Information
The client name is configurable via the `clientName` key in `Client/settings.json`. The client will take the value of this key and use it as its N_c value to encrypt and send to the server.

The server has a list of clients stored in `Server/clients.json`, storing key-value pairs of client names and paths to public key stores (*.pem).

Since there is only one known client to the server in this implementation, the value of `clientName` (`test_client_name`) in `Client/settings.json` must match the key in `Server/clients.json`, along with the corresponding value being the appropriate *.pem file (`client_public_key.pem`).

Keys and clients can be added and used as well by generating new keys, though this can only be seen when running the server locally since adding a new client would involve adding a new key on the cloud server. 
1. Run `python3 keygen.py <private_key_name.pem> <public_key_name_.pem>`
2. Place the newly generated `<private_key_name.pem>` file in the `Client` directory
3. Place the newly generated `<public_key_name.pem>` file in the `Server` directory
4. In `Client/settings.json`, change the `clientName` key value to a new name
5. In `Client/settings.json`, change the `clientPrivateKey` value to `<private_key_name.pem>`
6. In `Server/clients.json`, add a key-value pair for the new `clientName: <public_key_name.pem>`

## Communication
The client and server communicate over socket connections. The client immediately attempts to connect to the server upon starting. The server will listen and handle up to 5 clients concurrently. Each time a connection is accepted, the server kicks off a new thread to handle authentication protocol.

On successful authentication, the application-level connection is established and the client can explore the server with the `ls` or `pwd` commands. These are read-only commands that act as a proof of concept to test that the authentication behavior is acting as <b>Expected</b>. They are simple enough for easy communication over sockets and would not allow for a mistake such as deleting the server's private key file, which would make authentication fail every time.

## Keys and Crypto
The Crypto.PublicKey.RSA python module is used to generate public/private key pairs and encrypt/decrypt data.

## Core Logic
The `authenticate` function in `client.py` houses the authentication protocol as defined in the assignment and explained in the Overview section, and the `handleAuthRequest` function in `server.py` does the same for the server portion.


# Test Plan
## Overview
There are several scenariors for both the client and the server, particularly green light scenarios and authentication failures involving invalid client private key, client public key, server private key, and server public key, and invalid client name.

## Test Case 1: Greenlight on EC2 Instance
| Client | Server |
| ------ | ------ |
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: test_client_name,<session_key>` <br> `ec2-52-32-60-227.us-west-2.compute.amazonaws.com>`||
| Run: `ls` <br><br> <b>Expected</b>: Server directory listed ||
| Run: `ls ..` <br><br> <b>Expected</b>: Server parent directory listed ||
| Run: `pwd` <br><br> <b>Expected</b>: `/home/ubuntu/CS-475-Assignment-4/Server` ||
| Run: `quit` <br><br> <b>Expected</b>: `Goodbye` ||


## Test Case 2: Greenlight on Tux
| Client | Server |
| ------ | ------ |
|| In `./Server`: Run `python3 driver.py &` <br><br> <b>Expected</b>: `Started listening on port 13456...` |
|| Run `hostname` from working directory
| Open `./Client/settings.json` and change the value of the `"serverName"` key to `hostname` <br> (If the Server is running on tux, make sure to run the Client on tux as well) ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: test_client_name,<session_key>` <br> `hostname>` | <b>Expected</b>: `Handling request from <client_hostname>` (actual hostname, not clientname) |
| Run: `ls` <br><br> <b>Expected</b>: Server directory listed ||
| Run: `ls ..` <br><br> <b>Expected</b>: Server parent directory listed ||
| Run: `pwd` <br><br> <b>Expected</b>: Working directory printed
| Run: `quit` <br><br> <b>Expected</b>: `Goodbye`|
|| (<b><i>Keep Server running</i></b>) |

## Test Case 3: Invalid Client Private Key on Tux
| Client | Server |
| ------ | ------ |
|| 
| In `./Client`: Run `cp client_private_key.pem backup` <br> (Enter `y` to overwrite if prompted) ||
| Delete a row from `./Client/client_private_key.pem` ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Authentication Failed` ||
| In `./Client`: Run `cp backup client_private_key.pem` <br> (Enter `y` to overwrite if prompted) ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: test_client_name,<session_key>` <br> `hostname>` | <b>Expected</b>: `Handling request from <client_hostname>` (actual hostname, not clientname) |
| Run: `quit` <br><br> <b>Expected</b>: `Goodbye`||
|| (<b><i>Keep Server running</i></b>) |

## Test Case 4: Invalid Client Public Key on Tux
| Client | Server |
| ------ | ------ |
|| In `./Server`: Run `cp client_public_key.pem backup` <br> (Enter `y` to overwrite if prompted) |
|| Delete a row from `./Server/client_public_key.pem` ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Authentication Failed` ||
|| In `./Server`: Run `cp backup client_public_key.pem` <br> (Enter `y` to overwrite if prompted) |
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: test_client_name,<session_key>` <br> `hostname>` | <b>Expected</b>: `Handling request from <client_hostname>` (actual hostname, not clientname) |
| Run: `quit` <br><br> <b>Expected</b>: `Goodbye`||
|| (<b><i>Keep Server running</i></b>) |

## Test Case 5: Invalid Server Private Key on Tux
| Client | Server |
| ------ | ------ |
|| In `./Server`: Run `cp server_private_key.pem backup` (Enter `y` to overwrite if prompted) |
|| Delete a line from `./Server/server_private_key.pem` |
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Authentication Failed` ||
|| In `./Server`: Run `cp backup server_private_key.pem` (Enter `y` to overwrite if prompted) |
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: test_client_name,<session_key>` <br> `hostname>` | <b>Expected</b>: `Handling request from <client_hostname>` (actual hostname, not clientname) |
| Run: `quit` <br><br> <b>Expected</b>: `Goodbye`||
|| (<b><i>Keep Server running</i></b>) |

## Test Case 6: Invalid Server Public Key on Tux
| Client | Server |
| ------ | ------ |
| In `./Client`: Run `cp server_public_key.pem backup` (Enter `y` to overwrite if prompted) ||
| Delete a line from `./Client/server_public_key.pem` ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Authentication Failed` ||
| In `./Client`: Run `cp backup server_public_key.pem` ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: test_client_name,<session_key>` <br> `hostname>` | <b>Expected</b>: `Handling request from <client_hostname>` (actual hostname, not clientname) |
| Run: `quit` <br><br> <b>Expected</b>: `Goodbye`||
|| (<b><i>Keep Server running</i></b>) |

## Test Case 7: Adding a Second Client
| Client | Server |
| ------ | ------ |
| Open `./Client/settings.json` and change the value of the `"clientName"` key to `client2` ||
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Authentication Failed` ||
|| In `.` : Run `python3 keygen.py client2private.pem client2public.pem` |
| In `.` : Run `mv client2private.pem Client` |
| Open `./Client/settings.json` and change the value of the `"clientPrivateKey"` key to `client2private.pem` ||
|| In `.` : Run `mv client2public.pem Server` |
|| Open `./Server/clients.json` and add the following entry: `"client2": "client2public.pem"` |
| In `./Client`: Run `python3 driver.py` <br><br> <b>Expected</b>: `Successfully authorized. Server response: client2,<session_key>` <br> `hostname>` | <b>Expected</b>: `Handling request from <client_hostname>` (actual hostname, not clientname) |